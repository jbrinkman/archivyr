version: "3"

vars:
  GO_VERSION: "1.24.3"
  COVERAGE_FILE: reports/coverage/coverage.out
  COVERAGE_HTML: reports/coverage/coverage.html
  TEST_REPORT_DIR: reports/test
  DOCKER_IMAGE: mcp-ruleset-server
  DOCKER_TAG: latest

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  # Development tasks
  deps:
    desc: Download Go module dependencies
    cmds:
      - go mod download
      - go mod tidy

  fmt:
    desc: Format Go code
    cmds:
      - go fmt ./...

  # Linting tasks
  lint:
    desc: Run golangci-lint (same as CI)
    cmds:
      - golangci-lint run --timeout=5m

  lint:fix:
    desc: Run golangci-lint with auto-fix
    cmds:
      - golangci-lint run --timeout=5m --fix

  # Testing tasks
  test:
    desc: Run all tests with race detector and coverage (same as CI)
    cmds:
      - mkdir -p {{.TEST_REPORT_DIR}} reports/coverage
      - go test ./... -v -race -coverprofile={{.COVERAGE_FILE}} -covermode=atomic -json > {{.TEST_REPORT_DIR}}/test-results.json
      - cat {{.TEST_REPORT_DIR}}/test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/test-report.html
      - echo "Test report generated at {{.TEST_REPORT_DIR}}/test-report.html"

  test:unit:
    desc: Run unit tests only
    cmds:
      - mkdir -p {{.TEST_REPORT_DIR}}
      - go test ./internal/... -v -race -cover -json > {{.TEST_REPORT_DIR}}/unit-test-results.json
      - cat {{.TEST_REPORT_DIR}}/unit-test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/unit-test-report.html
      - echo "Unit test report generated at {{.TEST_REPORT_DIR}}/unit-test-report.html"

  test:integration:
    desc: Run integration tests
    cmds:
      - mkdir -p {{.TEST_REPORT_DIR}}
      - |
        if [ -d "./test/integration" ]; then
          go test ./test/integration/... -v -race -json > {{.TEST_REPORT_DIR}}/integration-test-results.json
          cat {{.TEST_REPORT_DIR}}/integration-test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/integration-test-report.html
          echo "Integration test report generated at {{.TEST_REPORT_DIR}}/integration-test-report.html"
        else
          echo "Integration tests directory not found, skipping..."
        fi

  test:e2e:
    desc: Run end-to-end tests
    cmds:
      - mkdir -p {{.TEST_REPORT_DIR}}
      - |
        if [ -d "./test/e2e" ]; then
          go test ./test/e2e/... -v -json > {{.TEST_REPORT_DIR}}/e2e-test-results.json
          cat {{.TEST_REPORT_DIR}}/e2e-test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/e2e-test-report.html
          echo "E2E test report generated at {{.TEST_REPORT_DIR}}/e2e-test-report.html"
        else
          echo "E2E tests directory not found, skipping..."
        fi

  test:coverage:
    desc: Run tests and generate coverage report
    cmds:
      - task: test
      - covreport -i {{.COVERAGE_FILE}} -o {{.COVERAGE_HTML}}
      - echo "Coverage report generated at {{.COVERAGE_HTML}}"

  test:coverage:combined:
    desc: Run all tests (unit + integration) and generate combined coverage report
    cmds:
      - mkdir -p reports/coverage/data {{.TEST_REPORT_DIR}}
      - rm -rf reports/coverage/data/*
      - echo "Running unit tests with coverage..."
      - go test ./internal/... -v -race -coverprofile=reports/coverage/data/unit.out -covermode=atomic -json > {{.TEST_REPORT_DIR}}/unit-test-results.json
      - cat {{.TEST_REPORT_DIR}}/unit-test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/unit-test-report.html
      - echo "Running integration tests with coverage (instrumenting all internal packages)..."
      - go test ./test/integration/... -v -race -coverprofile=reports/coverage/data/integration.out -coverpkg=./internal/... -covermode=atomic -json > {{.TEST_REPORT_DIR}}/integration-test-results.json
      - cat {{.TEST_REPORT_DIR}}/integration-test-results.json | go-test-report -o {{.TEST_REPORT_DIR}}/integration-test-report.html
      - echo "Note - E2E tests run in Docker containers and cannot capture coverage"
      - echo "Merging coverage reports..."
      - |
        echo "mode: atomic" > {{.COVERAGE_FILE}}
        tail -q -n +2 reports/coverage/data/*.out >> {{.COVERAGE_FILE}} 2>/dev/null || true
      - echo "Generating coverage summary..."
      - go tool cover -func={{.COVERAGE_FILE}} | grep total
      - echo "Coverage report saved to {{.COVERAGE_FILE}}"
      - echo "Run 'task test:coverage:html' to generate HTML report"

  test:coverage:html:
    desc: Generate HTML coverage report from existing coverage data
    cmds:
      - mkdir -p reports/coverage
      - covreport -i {{.COVERAGE_FILE}} -o {{.COVERAGE_HTML}}
      - echo "Coverage report generated at {{.COVERAGE_HTML}}"

  test:quick:
    desc: Run tests without race detector (faster for development)
    cmds:
      - go test ./... -v

  # Build tasks
  build:
    desc: Build the application binary
    cmds:
      - go build -o bin/mcp-ruleset-server ./cmd/mcp-ruleset-server

  build:all:
    desc: Build for multiple platforms
    cmds:
      - GOOS=linux GOARCH=amd64 go build -o bin/mcp-ruleset-server-linux-amd64 ./cmd/mcp-ruleset-server
      - GOOS=darwin GOARCH=amd64 go build -o bin/mcp-ruleset-server-darwin-amd64 ./cmd/mcp-ruleset-server
      - GOOS=darwin GOARCH=arm64 go build -o bin/mcp-ruleset-server-darwin-arm64 ./cmd/mcp-ruleset-server
      - GOOS=windows GOARCH=amd64 go build -o bin/mcp-ruleset-server-windows-amd64.exe ./cmd/mcp-ruleset-server

  # Docker tasks
  docker:build:
    desc: Build Docker image (same as CI)
    cmds:
      - docker build -f docker/Dockerfile -t {{.DOCKER_IMAGE}}:{{.DOCKER_TAG}} .

  docker:run:
    desc: Run Docker container locally
    cmds:
      - docker run -i {{.DOCKER_IMAGE}}:{{.DOCKER_TAG}}

  docker:test:
    desc: Run Docker smoke tests (same as CI)
    cmds:
      - task: docker:build
      - |
        # Start container in background
        docker run -d --name mcp-test {{.DOCKER_IMAGE}}:{{.DOCKER_TAG}}

        # Wait for container to initialize
        sleep 5

        # Check if container is running
        if ! docker ps | grep -q mcp-test; then
          echo "Container failed to start"
          docker logs mcp-test
          docker rm -f mcp-test 2>/dev/null || true
          exit 1
        fi

        # Check container logs for successful startup
        docker logs mcp-test

        # Cleanup
        docker stop mcp-test
        docker rm mcp-test

  # CI simulation tasks
  ci:
    desc: Run full CI pipeline locally (lint + test + docker)
    cmds:
      - task: lint
      - task: test
      - task: test:integration
      - task: docker:test
      - task: test:e2e

  ci:quick:
    desc: Run quick CI checks (lint + unit tests)
    cmds:
      - task: lint
      - task: test:unit

  # Cleanup tasks
  clean:
    desc: Clean build artifacts and test cache
    cmds:
      - rm -rf bin/
      - rm -rf reports/
      - rm -rf coverdata/
      - rm -f coverage.out coverage.html
      - go clean -testcache
      - docker rm -f mcp-test 2>/dev/null || true

  clean:all:
    desc: Clean everything including Docker images
    cmds:
      - task: clean
      - docker rmi {{.DOCKER_IMAGE}}:{{.DOCKER_TAG}} 2>/dev/null || true

  # Verification tasks
  verify:
    desc: Verify code is ready for commit (format, lint, test)
    cmds:
      - task: fmt
      - task: lint
      - task: test:unit

  # Development workflow tasks
  dev:setup:
    desc: Set up development environment
    cmds:
      - task: deps
      - echo "Installing golangci-lint..."
      - go install github.com/golangci/golangci-lint/cmd/golangci-lint@latest
      - echo "Installing covreport..."
      - go install github.com/cancue/covreport@latest
      - echo "Installing go-test-report..."
      - go install github.com/vakenbolt/go-test-report@latest
      - echo "Development environment ready!"

  dev:watch:
    desc: Watch for changes and run tests (requires entr)
    cmds:
      - |
        if ! command -v entr &> /dev/null; then
          echo "entr is not installed. Install it with: brew install entr (macOS) or apt-get install entr (Linux)"
          exit 1
        fi
        find . -name '*.go' | entr -c task test:quick
